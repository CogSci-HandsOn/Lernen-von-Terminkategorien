
# coding: utf-8

# In[156]:

"""
============
Convert data
============

A module that provides functions to read a .csv file and convert the
contained information into convenient formats that can be used for feature
extraction.
"""

import csv
import datetime

import numpy as np
from sklearn.preprocessing import scale, maxabs_scale
from sklearn.decomposition import PCA
from sklearn.cross_validation import train_test_split

import holidays
import bisect

# Maps the date categories onto integer codes
LABEL_MAPPING = {
	'S-B - intern (901106)' : 0,
	'ISO Zertifizierung smO (2990191)' : 1,
	'ISO Zertifizierung SWO Netz (2910667)' : 2,
	'E - intern (901107)' : 3,
	'E - MPM (2900041)' : 4,
	'E - smartTT' : 5,
	'S-B - smartTT2.0 (901106)' : 6,
	'Noch nicht zugeordnet' : 7
	}

def load_data(filename='data', pca=0):

	# Retrieve features and labels from file
	X, y = get_features(filename)[0:2]
	# Standardize features
	# X = maxabs_scale(X)
	X = scale(X)

	# Apply pca if necessary
	if pca > 0:
		pca = PCA(pca)
		X = pca.fit_transform(X)

	n_features = X.shape[1]
	n_classes = len(set(y))

	# Split data into train, validation and test data sets
	X_train, X_val, y_train, y_val \
		= train_test_split(
			X, y, test_size=0.15, random_state=42)

	n_samples = [X_train.shape[0], X_val.shape[0]]

	# Nest sets in D
	D = [(X_train, y_train), (X_val, y_val)]

	n_samples = [subset[0].shape[0] for subset in D]
	params = (n_features, n_classes, n_samples)

	return D, params

def get_features(filename="data"):
	print('... loading data')
	# We need our data sorted so we can easily acces it later
	return extract_features(sorted(convert_data(read_data(filename))))

def get_data(filename="data"):
	return sorted(convert_data(read_data(filename)))


def read_data(filename):
	"""Loads each row of a .csvfile and puts them into a list.

	The output is a list containing rows of the input file as list
	entries. Each entry is itself another list containing all the column
	entries of the file.

	Args:
		filename: The input file name as a string. Needs to be a .csv.

	Returns:
		A list containing the rows of the file.

	"""
	raw_data = []
	with open('../res/'+filename+'.csv', newline='') as f:
		data_reader = csv.reader(f, delimiter=';')
		for row in data_reader:
			raw_data.append(row)
		del raw_data[0]
	return raw_data

def convert_data(raw_data):
	"""Converts the data read from a file into a convenient format.

	Calls the 'read_data' function in order to retrieve information from
	the given input .csv file. This data is then converted into a format
	that can be used later.
	The exact starting point is converted into a 'datetime.datetime' object.
	The end time is also are converted into 'datetime.datetime' object.
	The string labels are converted into a coding scheme of integers defined
	at the top of the module.

	Args:
		filename: The input file name as a string. Needs to be a .csv.

	Returns:
		A list of which entries are lists containing the data in
		convenient formats. It has dimensions of ('num_samples, 4'). This list can
		be used by 'extract_features' in order to retrieve a numeric
		array.
	"""
	data = []
	for i in range(len(raw_data)):
		data_i = []
		# Convert begin. i.e. date+starttime
		data_i.append(convert_datetime(raw_data[i][0], raw_data[i][1]))

		# Convert end. i.e. date+endtime
		data_i.append(convert_datetime(raw_data[i][0], raw_data[i][2]))

		# Convert label
		data_i.append(convert_label(raw_data[i][3]))

		# Appends the complete date to the list
		data.append(data_i)

	return data


# Feature extraction

def extract_features(data):
	"""Creates a feature matrix out of the raw data.

	Takes the formatted data out of the 'convert_data' function and
	extracts 10 numerical features out of it.

	Args:
		data: A formatted list of input data generated by 'convert_data'.

	Returns:
		A numpy array of dimension (len(data), 12) containing numeric
		features.

		The 1st column holds the ordinal of each date (The count from
		2015-01-01) and hence, the absolute time.
		The 2nd column holds the year of the date.
		The 3rd column holds the month of the date.
		The 4th column holds the day of the year.
		The 5th column holds the day of the month.
		The 6th column holds the day of the week, where 0 is Monday and
		6 is Sunday.
		The 7th column holds whether the day is on weekend (1) or not (0).
		The 8th column holds the week of the year.
		The 9th column holds the week of the month.
		The 10th column holds whether the date is a holiday(1) or not (0).
	"""
	time_range = 8
	num_features_per_date = 12
	labels = [0] * len(data)
	delta_times_for_regular_events = [-14, -7, -1, 1, 7, 14 ]
	#when we later check what the event was e.g. exactly one week before

	features = np.zeros((len(data), num_features_per_date*time_range+(len(delta_times_for_regular_events))+7))
	initial_date = datetime.date(2015, 1, 1)
	holiday_dates = holidays.Germany(state='NI', years=[2015, 2016, 2017, 2018, 2019, 2020])
	timeForm = '%H:%M:%S'
	startWork = '08:00:00'
	endWork = '18:00:00'
	startLunch = '11:30:00'
	endLunch = '12:30:00'


	for i, sample in enumerate(data):
		labels[i] = data[i][2][0]
		## Features concerning the date

		date = data[i][0].date()
		for time_offset in range(time_range):
			day = date + datetime.timedelta(days=time_offset-time_range/2)
			offset = time_offset*num_features_per_date

			# Ordinal of day
			features[i,0+offset] = day.toordinal() - initial_date.toordinal()
			# Year
			features[i,1+offset] = day.year
			# Month of year
			features[i,2+offset] = day.month
			# Day of year
			features[i,3+offset] = day.toordinal() 				- datetime.date(day.year, 1, 1).toordinal() + 1
			# Day of month
			features[i,4+offset] = day.day
			# Weekday
			features[i,5+offset] = day.weekday()
			# Weekend 1 / week 0
			features[i,6+offset] = features[i,5+offset] == 5 or 				features[i,5+offset] == 6
			# Week of year # TODO: Kalenderwoche
			features[i,7+offset] = np.floor(features[i,3] / 7)
			# Week of month
			features[i,8+offset] = np.floor(features[i,4] / 7)
			# Holiday
			features[i,9+offset] = day in holiday_dates
			# Specific holidays
			try:
				holiday = holiday_dates[day]
				# Christmas
				if holiday == 'Erster Weihnachtstag' or 					holiday == 'Zweiter Weihnachtstag':
					features[i,10+offset] = 1
				# Easter
				elif holiday == 'Ostermontag':
					features[i,11+offset] = 1
			except KeyError:
				features[i,10+offset] = 0
				features[i,11+offset] = 0

			# TODO: Brückentag

			# taking care of regular events -----
			# category of event x days different from the current event
			# as feature e.g. -7: (which event was exactly one week before
			# at the same time)
			start_i_regular = time_range*num_features_per_date
			# we have time_range times num_features_per_date features
			# so far. so we start after that. (use that as index)

			for i_reg, delta_days in enumerate(delta_times_for_regular_events):
				features[i,start_i_regular+i_reg] = event_before(data, sample[0], datetime.timedelta(delta_days))

		# Features concerning the time
		pos = start_i_regular + i_reg + 1
		begin = str(data[i][0].time())
		end = str(data[i][1].time())
		# Duration in seconds
		features[i,pos] = datetime.timedelta.total_seconds(datetime.datetime.strptime(end,timeForm) -
															datetime.datetime.strptime(begin,timeForm))
		# Extra long entry? (Longer than 3 hours)
		features[i,pos+1] = int(features[i,pos]>10800)
		# Extra short entry? (shorter than 1 hour)
		features[i,pos+2] = int(features[i,pos]<3600)
		# Before lunch?
		features[i,pos+3] = int(begin<startLunch)
		# Not in usual working hours?
		features[i,pos+4] = int((begin<startWork) or (end>endWork))
		# Entry over lunch break
		features[i,pos+5] = int((begin<startLunch) and (end>endLunch))
		# Conflict/overlap with another entry
		if date == data[i-1][1].date():
			endPrev = str(data[i-1][1].time())
			features[i,pos+6] = int(endPrev > begin)
		try: # To handle last entry
			if date == data[i+1][0].date() and features[i,pos+6] == 0:
				startNext = str(data[i+1][0].time())
				features[i,pos+6] = int((startNext < end))
		except IndexError:
			features[i,pos+6] = 0

		## Features concerning the time
		default_names = ['Ordinal', 'Year', 'Month', 'Day of Year', 'Day of Month',
			'Weekday', 'Weekend', 'Week of year', 'Week of month', 'Holiday',
			'Christmas', 'Easter']
		names = []
		for i in range(time_range):
			for name in default_names:
				names.append(name+' of day {}'.format(i-4))

	return features, np.array(labels), names


# Conversion helpers

def convert_datetime(date_str, time_str):
	date_list = [int(x) for x in date_str.split(sep='.')]
	time_list = [int(x) for x in time_str.split(sep=':')]
	return datetime.datetime(date_list[2], date_list[1], date_list[0], time_list[0], time_list[1], time_list[2])


def convert_label(label_str):
	labels = label_str.split(sep=',')
	return [LABEL_MAPPING[label] for label in labels]

def event_before(sorted_data, current_time, delta_time):
	"""
		returns the category of the event delta_time away from the current one.
		delta_time is added to the current date
		if there was no event at exactly that time it will return -1
	"""

	#when combaring lists, python first compares the first elements of the list.
	target_time = current_time+delta_time

	try:
		target_event = sorted_data[index_startdate(sorted_data, target_time)]
		#print("event found")
		return target_event[2][0]  #return the first category of that event. TODO think wether it makes sense to simpy use the first category
	except ValueError:
		#print(" there was no event found at that time")
		return -1 #if no event was found. TODO think wether that makes any sense



# helper

# TODO: einfach den kategoriewert zurückgeben den es vor delta-time gab.

def index_startdate(data, x):
	"""
		Locate the leftmost event with start-time exactly equal to x in a sorted list
		data is the matrix of data
		x is the startingtime as datetime object.
		returns i: index of event that has the same startingtime
	"""
	i = bisect.bisect_left(data, [x])
	#since data is a list of lists we need to envelope the startingdate x in a list so the comparison works
	if i != len(data) and data[i][0] == x:
		return i
	raise ValueError("Element not in list")
